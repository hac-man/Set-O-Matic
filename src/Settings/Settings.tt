<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #><#@ template debug="true" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ Assembly Name="System.Configuration.dll" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="EnvDTE" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Configuration" #>
<#@ import namespace="System.Collections.Specialized" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>

// This file was generated by the template Settings.tt. Do not edit directly. Instead, edit the applciation's configuration file (App.config/Web.Config) and regenerate this code by right-clicking on the file and selecting "Run custom tool".<#
    // This T4 template generates a static class with properties for each app setting defined in the App.config file.
    var hostServiceProvider = (IServiceProvider)Host;
    var dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
    var activeSolutionProjects = (Array)dte.ActiveSolutionProjects; 
    var dteProject = (EnvDTE.Project)activeSolutionProjects.GetValue(0);
    var defaultNamespace = dteProject.Properties.Item("DefaultNamespace").Value;
    var templateDir = Path.GetDirectoryName(Host.TemplateFile);
    var fullPath = dteProject.Properties.Item("FullPath").Value.ToString();
    fullPath = fullPath.EndsWith("\\")
            ? fullPath.Substring(0, fullPath.Length-1)
            : fullPath;
    var subNamespace = templateDir.Replace(fullPath, string.Empty).Replace("\\", ".");
    var fileNamespace = defaultNamespace; // string.Concat(defaultNamespace, subNamespace);
    string configFile = string.Empty;
    try
    {

        if (File.Exists(this.Host.ResolvePath("..\\App.Config")))  
            configFile = this.Host.ResolvePath("..\\App.Config");
	    else if (File.Exists(this.Host.ResolvePath("..\\Web.Config")))
		    configFile = this.Host.ResolvePath("..\\Web.Config");
	    else
		    throw new FileNotFoundException("App.config or Web.config not found in the project directory."); 
    }
    catch(Exception ex)
    {
        #>
    

        //WARNING: No App.config or Web.config file found. Set-O-Matic should only be used in executable and web application projects.
        <#
        throw new Exception("Set-O-Matic should only be used in executable and web application projects.", ex);
    }
    var appSettings = GetAllConfigSettings(configFile).OrderBy(s => s.Key);
    if (!appSettings.Any())
    {
    #>   
namespace <#=fileNamespace#>
{
    public static partial class Settings
    {
            //Set-O-Matic: No application settings were found.
            public static bool IsLoaded { get; set;}
     }
}
    <#}
    else
    {
#>    

namespace <#=fileNamespace#>
{
    using System;
    public static partial class Settings
    {
        public static bool IsLoaded{get; internal set;}

        static void Initialize(){}

        static Settings()
		{
            if (!IsLoaded)
                new SetOMatic().LoadSettings();
		}
<#

  

    string previousSection = null; 
    string currentSection = null;  

    foreach (var setting in appSettings) 
    {
        currentSection = setting.Key; 
        if (previousSection != currentSection && previousSection != null && appSettings.Any())
        {
        #>
    }
<#
       
	    }
        if (previousSection == null || previousSection != currentSection)
	    {
        #>
        public static class <#=setting.Key #>
        {
            static <#=setting.Key#>()
		    {        
               Initialize();
		    }
    <#   
        }
                KeyValuePair<string, string> setPair = setting.Value;

        if (string.IsNullOrEmpty(setPair.Key))
            throw new Exception("All configuration entries must have a key specified and all connection strings must have a name specified");
        #>
        public static <#=GetPropertyType(GetTypeByValue(setPair.Value).Name)#> <#=setPair.Key.Replace('.', '_').Replace(' ', '_')#> {get; internal set;}
    <#

              previousSection = currentSection;
              }
         }
         
         if (appSettings.Any())
         {
        #>
    }
    }
}<#
         }
      static Type GetTypeByValue(string Value)
        {
            if (int.TryParse(Value, out _))
                return typeof(int);
            else if (bool.TryParse(Value, out _))
                return typeof(bool);
            else if (double.TryParse(Value, out _))
                return typeof(double);
            else if (float.TryParse(Value, out _))
                return typeof(float);
            else if (long.TryParse(Value, out _))
                return typeof(long);
            else if (DateTime.TryParse(Value, out _))
                return typeof(DateTime);
            else
                return typeof(string);
        }


        static string GetPropertyType(string ReflectedType)
        {
            switch (ReflectedType)
			{
				case "Int32":
					return "int";
				case "Boolean":
					return "bool";
				case "Double":
					return "double";
				case "Single":
					return "float";
				case "Int64":
					return "long";
				case "DateTime":
					return "DateTime";
				default:
					return "string";
			}
        }
        
        static List<KeyValuePair<string, KeyValuePair<string, string>>> GetAllConfigSettings(string ConfigPath)
        {
            XmlDocument configFile = new XmlDocument();
            configFile.Load(ConfigPath);
            return GetChildSettingSections(configFile.DocumentElement);
        }

        static List<KeyValuePair<string, KeyValuePair<string, string>>> GetChildSettingSections(XmlNode ParentNode)
        {
            List<KeyValuePair<string, KeyValuePair<string, string>>> ret = new List<KeyValuePair<string, KeyValuePair<string, string>>>();
            
            if (ParentNode.ChildNodes.Count > 0)
            {
                foreach (XmlNode childNode in ParentNode.ChildNodes)
                {
                    if (!childNode.HasChildNodes && childNode.Name == "add")
                    {
                        string sectionName = ParentNode.Name;
                        string key = null;
                        string value = null;

                        for (int i = 0; i < childNode.Attributes.Count; i++)
                        {
                            if (childNode.Attributes[i].Name == "Key" && string.IsNullOrEmpty(childNode.Attributes[i].Value))
                                throw new Exception("Key attribute is required for 'add' elements.");
                            if (childNode.Attributes[i].Name == "value" && string.IsNullOrEmpty(childNode.Attributes[i].Value))
                                value = null;
                            if (childNode.Attributes[i].Name == "key")
                               key = childNode.Attributes[i].Value;
                            if (childNode.Attributes[i].Name == "value")
                                value = childNode.Attributes[i].Value;
                            if (childNode.Attributes[i].Name == "name")
                                if (childNode.Attributes[i].Value == null)
                                    throw new Exception("Connection strings must have a name attribute");
                                else
                                    key = childNode.Attributes[i].Value;
                            if (childNode.Attributes[i].Name == "connectionString")
								value = childNode.Attributes[i].Value;
                        }

                        ret.Add(new KeyValuePair<string, KeyValuePair<string, string>>(sectionName, new KeyValuePair<string, string>(key, value)));
                    }
                    else if (childNode.HasChildNodes)
                        ret.AddRange(GetChildSettingSections(childNode));
                }
            }
            return ret;
        }
#>
